# Flax to Axon - Interactive Tool

```elixir
Mix.install([
  {:axon, "~> 0.6.1"},
  {:stream_data, "~> 1.1"},
  {:nx, "~> 0.7.2"},
  {:safetensors, "~> 0.1.3"},
  {:kino, "~> 0.12.3"},
  {:langchain, "~> 0.2.0"}
])

asdf_dir = "#{__DIR__}/.asdf"

unless File.exists?(asdf_dir) do
  {_, 0} =
    System.cmd("git", [
      "clone",
      "https://github.com/asdf-vm/asdf.git",
      asdf_dir,
      "--branch",
      "v0.14.0"
    ])
end

asdf = "#{asdf_dir}/bin/asdf"
{_, 0} = System.cmd(asdf, ["plugin", "add", "python"], env: [{"ASDF_DATA_DIR", asdf_dir}])

{_, 0} =
  System.cmd(asdf, ["install", "python", "3.11.9"], env: [{"ASDF_DATA_DIR", "#{__DIR__}/.asdf"}])

asdf_python = Path.join([asdf_dir, "installs", "python", "3.11.9", "bin", "python"])

python_packages =
  ~w(
    safetensors
    torch
    transformers
    accelerate
    numpy
    datasets
    pillow
    flax
    jax
    jaxlib
  )

venv_dir = Path.join(__DIR__, "flax2axon_env")
{_, 0} = System.cmd(asdf_python, ["-m", "venv", "--copies", venv_dir])

python = Path.join([venv_dir, "bin", "python"])
pip = Path.join([venv_dir, "bin", "pip"])

{_, 0} = System.cmd(pip, ["install" | python_packages])

run_python = fn command, opts ->
  System.cmd(python, ["-c", command], opts)
end

data_dir = Path.join(__DIR__, "data")

unless File.exists?(data_dir), do: :ok = File.mkdir(data_dir)
```

## WARNING

> __This Livebook installs asdf, Python and some libraries in the directory of the livebook.__
> Modify the notebook setup if you don't want that.
> 
> It also __blindly runs LLM generated Elixir code__ using `Code.eval_string`. Don't use the `FixChain` if you don't want that.

## Introduction

You must set the `OPENAI_KEY` secret to your api key.

```elixir
api_key = System.get_env("LB_OPENAI_KEY")
```

### Goals

* (Semi-) Automatically convert Flax models to Axon (from `transformers`/`diffusers`)
* Verify that models compute same results for same inputs

For now, we consider only Flax (linen) because it's similar to Axon and should be easier than PyTorch or TensorFlow

<!-- livebook:{"break_markdown":true} -->

```mermaid
flowchart TD
    Input[Read Flax File]
    Classes[Split into classes and free functions]

    subgraph each_class[for each class/free function]
      subgraph conversion[Convert into Axon]
        Convert[Convert using LLM instructions]
        Replace[Replace previously \n converted classes \n with Axon function]
      end
      subgraph verify[Verify same results]
        direction TB
        Generate[Generate input and params in Elixir]
        Compute_axon[Compute results in Axon]
        Safetensors[Save everything in safetensors]
        Load[Load safetensors in Python]
        Compute_flax[Compute results in Flax]
        Compare[Compare outputs for inputs]
      end

      Store[Store resulting Axon function]
    end


    Input-->Classes-->each_class

    Convert-->Replace
    Convert-->Convert
    conversion-->verify

    Generate-->Compute_axon-->Safetensors-->Load-->Compute_flax-->Compare

    verify-->Store
```

```elixir
transformers_path = Path.join(venv_dir, "lib/python3.11/site-packages/transformers")
resnet_flax_path = Path.join(transformers_path, "models/resnet/modeling_flax_resnet.py")

{:ok, resnet_input} = File.read(resnet_flax_path)
```

```elixir
resnet_flax_path
```

## Get inputs

```elixir
input = resnet_input
```

We get the individual classes

```elixir
inputs_fn = fn input ->
  [_ | inputs] = Regex.split(~r{\n(class |def )\b}, input, include_captures: true)

  separators = Enum.take_every(inputs, 2)
  rest = Enum.drop(inputs, 1) |> Enum.take_every(2)

  Enum.zip_with(separators, rest, fn sep, r ->
    String.trim_leading(sep) <> r
  end)
end
```

```elixir
extract_names = fn flax_code ->
  [flax_model_name | _] = String.split(flax_code, "(")
  flax_model_name = String.trim_leading(flax_model_name, "class ")
  axon_model_function_name = Macro.underscore(flax_model_name)
  {flax_model_name, axon_model_function_name}
end
```

Might need to figure out which classes depend on which other classes. Then, we do the following for each of them.

## Conversion

```elixir
alias LangChain.Chains.LLMChain
alias LangChain.ChatModels.ChatOpenAI
alias LangChain.Message
```

Define system messages to make this work better.

```elixir
system_messages =
  [
    """
    You are an expert in machine learning frameworks.
    You help converting models from Python code in Flax linen framework to Elixir code in the Axon framework.
    """,
    """
    You will do this by following instructions step by step.
    """,
    """
    I will provide you with the model code and an instruction in the following format:
    INSTRUCTION: here is the instruction you perform
    MODEL: here is the model code you will modify
    """,
    """
    For each of the following instructions, reply only with the modified code of the model.
    Do NOT include any other content or comments.
    """,
    """
    Perform ONLY the action the instruction asks you to do.
    """,
    """
    In case you don't change anything return ONLY the unchanged model code.
    """
  ]
  |> Enum.map(&Message.new_system!/1)
```

#### Conversion Tables

<!-- livebook:{"break_markdown":true} -->

Created using ChatGPT and refining format.

<!-- livebook:{"break_markdown":true} -->

##### Layers

Prompt:

Fetch the documentation about layers in Flax linen from here: https://flax.readthedocs.io/en/latest/api_reference/flax.linen/layers.html

Build a separate markdown table for each of the layers in Flax linen and the corresponding layer in Axon.
Each table should have two rows:
First row: shows the Flax linen layer in the first column, then a column for each parameter it takes. Prefix the linen layer with `nn.`
 Second row: shows the corresponding Axon layer in the first column, then the corresponding Axon parameter to each of the Flax linen parameters. Prefix the Axon layer with `Axon.Layer.`

If there is no corresponding layer, or no corresponding parameter, add a "-" instead.

Here an example for the Conv layer of Flax linen:

|      |           |          |             |         |         |       |          |                    |
| ---- | --------- | -------- | ----------- | ------- | ------- | ----- | -------- | ------------------ |
| Flax | nn.Conv   | features | kernel_size | strides | padding | dtype | use_bias | kernel_init        |
| Axon | Axon.conv | units    | kernel_size | strides | padding | -     | use_bias | kernel_initializer |

```elixir
conversion_layers =
  """
  ### Conv Layer

  |          | Layer     | features | kernel_size | strides | padding | dtype | use_bias | kernel_init        |
  | -------- | --------- | -------- | ----------- | ------- | ------- | ----- | -------- | ------------------ |
  | **Flax** | nn.Conv   | features | kernel_size | strides | padding | dtype | use_bias | kernel_init        |
  | **Axon** | Axon.conv | units    | kernel_size | strides | padding | -     | use_bias | kernel_initializer |

  ### Dense Layer

  |          | Layer      | features | use_bias | kernel_init        |
  | -------- | ---------- | -------- | -------- | ------------------ |
  | **Flax** | nn.Dense   | features | use_bias | kernel_init        |
  | **Axon** | Axon.dense | units    | use_bias | kernel_initializer |

  ### Dropout Layer

  |          | Layer        | rate |
  | -------- | ------------ | ---- |
  | **Flax** | nn.Dropout   | rate |
  | **Axon** | Axon.dropout | rate |

  ### BatchNorm Layer

  |          | Layer           | use_running_average | axis | momentum | epsilon | dtype |
  | -------- | --------------- | ------------------- | ---- | -------- | ------- | ----- |
  | **Flax** | nn.BatchNorm    | use_running_average | axis | momentum | epsilon | dtype |
  | **Axon** | Axon.batch_norm | -                   | axis | momentum | epsilon | -     |

  ### LayerNorm Layer

  |          | Layer           | axis | epsilon | dtype |
  | -------- | --------------- | ---- | ------- | ----- |
  | **Flax** | nn.LayerNorm    | axis | epsilon | dtype |
  | **Axon** | Axon.layer_norm | axis | epsilon | -     |

  ### Relu Layer

  |          | Layer     |
  | -------- | --------- |
  | **Flax** | nn.relu   |
  | **Axon** | Axon.relu |

  ### Sigmoid Layer

  |          | Layer        |
  | -------- | ------------ |
  | **Flax** | nn.sigmoid   |
  | **Axon** | Axon.sigmoid |

  ### Tanh Layer

  |          | Layer     |
  | -------- | --------- |
  | **Flax** | nn.tanh   |
  | **Axon** | Axon.tanh |

  ### MaxPool Layer

  |          | Layer         | window_shape | strides | padding |
  | -------- | ------------- | ------------ | ------- | ------- |
  | **Flax** | nn.max_pool   | window_shape | strides | padding |
  | **Axon** | Axon.max_pool | kernel_size  | strides | padding |

  ### AvgPool Layer

  |          | Layer         | window_shape | strides | padding |
  | -------- | ------------- | ------------ | ------- | ------- |
  | **Flax** | nn.avg_pool   | window_shape | strides | padding |
  | **Axon** | Axon.avg_pool | kernel_size  | strides | padding |

  ### GlobalAvgPool Layer

  |          | Layer                |
  | -------- | -------------------- |
  | **Flax** | nn.global_avg_pool   |
  | **Axon** | Axon.global_avg_pool |

  ### Flatten Layer

  |          | Layer        |
  | -------- | ------------ |
  | **Flax** | nn.Flatten   |
  | **Axon** | Axon.flatten |
  """

Kino.Markdown.new(conversion_layers)
```

#### Initializers

Prompt:

Fetch the documentation about initializers in Axon from here: https://hexdocs.pm/axon/Axon.Initializers.html  
Fetch the documentation about initializers in Flax linen from here: https://flax.readthedocs.io/en/latest/api_reference/flax.linen/initializers.html

Build a separate markdown table for each of the initializers in Flax linen and the corresponding initializer in Axon.
Each table should have two rows:
First row: shows the Flax linen initializer in the first column, then a column for each parameter it takes. Prefix the linen initializer with `nn.`
 Second row: shows the corresponding Axon initializer in the first column, then the corresponding Axon parameter to each of the Flax linen parameters. Prefix the Axon initializer with `Axon.Layer.`

If there is no corresponding initializer, or no corresponding parameter, add a "-" instead.

Here an example for the `initializers.variance_scaling` of Flax linen:

|      |                                  |       |      |              |         |          |            |       |
| ---- | -------------------------------- | ----- | ---- | ------------ | ------- | -------- | ---------- | ----- |
| Flax | nn.initializers.variance_scaling | scale | mode | distribution | in_axis | out_axis | batch_axis | dtype |

| Axon  | Axon.Initializers.variance_scaling | scale | mode | distribution |

```elixir
conversion_initializers =
  """
  ### Variance Scaling

  |      |                                    |       |      |              |         |          |            |       |
  | ---- | ---------------------------------- | ----- | ---- | ------------ | ------- | -------- | ---------- | ----- |
  | Flax | nn.initializers.variance_scaling   | scale | mode | distribution | in_axis | out_axis | batch_axis | dtype |
  | Axon | Axon.Initializers.variance_scaling | scale | mode | distribution | -       | -        | -          | -     |

  ### Glorot Normal

  |      |                                 |       |
  | ---- | ------------------------------- | ----- |
  | Flax | nn.initializers.glorot_normal   | dtype |
  | Axon | Axon.Initializers.glorot_normal | -     |

  ### Glorot Uniform

  |      |                                  |       |
  | ---- | -------------------------------- | ----- |
  | Flax | nn.initializers.glorot_uniform   | dtype |
  | Axon | Axon.Initializers.glorot_uniform | -     |

  ### Lecun Normal

  |      |                                |       |
  | ---- | ------------------------------ | ----- |
  | Flax | nn.initializers.lecun_normal   | dtype |
  | Axon | Axon.Initializers.lecun_normal | -     |

  ### Lecun Uniform

  |      |                                 |       |
  | ---- | ------------------------------- | ----- |
  | Flax | nn.initializers.lecun_uniform   | dtype |
  | Axon | Axon.Initializers.lecun_uniform | -     |

  ### Orthogonal

  |      |                              |              |
  | ---- | ---------------------------- | ------------ |
  | Flax | nn.initializers.orthogonal   | scale        |
  | Axon | Axon.Initializers.orthogonal | distribution |

  ### Constant

  |      |                          |       |
  | ---- | ------------------------ | ----- |
  | Flax | nn.initializers.constant | value |
  | Axon | Axon.Initializers.full   | value |

  ### Normal

  |      |                          |      |        |
  | ---- | ------------------------ | ---- | ------ |
  | Flax | nn.initializers.normal   | mean | stddev |
  | Axon | Axon.Initializers.normal | mean | scale  |

  ### Uniform

  |      |                           |        |        |
  | ---- | ------------------------- | ------ | ------ |
  | Flax | nn.initializers.uniform   | minval | maxval |
  | Axon | Axon.Initializers.uniform | -      | scale  |

  ### Identity

  |      |                            |
  | ---- | -------------------------- |
  | Flax | nn.initializers.identity   |
  | Axon | Axon.Initializers.identity |

  ### Ones

  |      |                        |
  | ---- | ---------------------- |
  | Flax | nn.initializers.ones   |
  | Axon | Axon.Initializers.ones |

  ### Zeros

  |      |                         |
  | ---- | ----------------------- |
  | Flax | nn.initializers.zeros   |
  | Axon | Axon.Initializers.zeros |
  """

Kino.Markdown.new(conversion_initializers)
```

#### Activation Functions

Prompt:

Fetch the documentation about activations in Axon from here: https://hexdocs.pm/axon/Axon.Activations.html  
Fetch the documentation about activations in Flax linen from here: https://flax.readthedocs.io/en/latest/api_reference/flax.linen/activation_functions.html

Build a separate markdown table for each of the activations in Flax linen and the corresponding activation in Axon.
Each table should have two rows:
First row: shows the Flax linen activation in the first column, then a column for each parameter it takes. Prefix the linen activation with `nn.`
 Second row: shows the corresponding Axon activation in the first column, then the corresponding Axon parameter to each of the Flax linen parameters. Prefix the Axon activation with `Axon.Activations.`

If there is no corresponding activation, or no corresponding parameter, add a "-" instead.

Here an example for `activation.softmax` of Flax linen:

|      |                          |      |       |         |
| ---- | ------------------------ | ---- | ----- | ------- |
| Flax | nn.activation.softmax    | axis | where | initial |
| Axon | Axon.Activations.softmax | axis | -     | -       |

```elixir
conversion_activations =
  """
  ### Softmax

  |      |                          |      |       |         |
  | ---- | ------------------------ | ---- | ----- | ------- |
  | Flax | nn.softmax               | axis | where | initial |
  | Axon | Axon.Activations.softmax | axis | -     | -       |

  ### ReLU

  |      |                       |
  | ---- | --------------------- |
  | Flax | nn.relu               |
  | Axon | Axon.Activations.relu |

  ### Leaky ReLU

  |      |                             |                |
  | ---- | --------------------------- | -------------- |
  | Flax | nn.leaky_relu               | negative_slope |
  | Axon | Axon.Activations.leaky_relu | alpha          |

  ### Sigmoid

  |      |                          |
  | ---- | ------------------------ |
  | Flax | nn.sigmoid               |
  | Axon | Axon.Activations.sigmoid |

  ### Tanh

  |      |                       |
  | ---- | --------------------- |
  | Flax | nn.tanh               |
  | Axon | Axon.Activations.tanh |

  ### GELU

  |      |                       |             |
  | ---- | --------------------- | ----------- |
  | Flax | nn.gelu               | approximate |
  | Axon | Axon.Activations.gelu | -           |

  ### ELU

  |      |                      |       |
  | ---- | -------------------- | ----- |
  | Flax | nn.elu               | alpha |
  | Axon | Axon.Activations.elu | alpha |

  ### SELU

  |      |                       |
  | ---- | --------------------- |
  | Flax | nn.selu               |
  | Axon | Axon.Activations.selu |

  ### Softplus

  |      |                           |
  | ---- | ------------------------- |
  | Flax | nn.softplus               |
  | Axon | Axon.Activations.softplus |

  ### Swish

  |      |                        |
  | ---- | ---------------------- |
  | Flax | nn.swish               |
  | Axon | Axon.Activations.swish |

  ### Log Softmax

  |      |                              |      |       |         |
  | ---- | ---------------------------- | ---- | ----- | ------- |
  | Flax | nn.log_softmax               | axis | where | initial |
  | Axon | Axon.Activations.log_softmax | axis | -     | -       |
  """

Kino.Markdown.new(conversion_activations)
```

```elixir
conversion_messages =
  [
    conversion_layers,
    conversion_initializers,
    conversion_activations
  ]
  |> Enum.map(&Message.new_system!/1)
```

Define the langchain

```elixir
defmodule ConversionChain do
  def new!(api_key, system_messages, conversion_messages) do
    {:ok, chain, _response} =
      %{
        llm:
          ChatOpenAI.new!(%{
            model: "gpt-4o",
            api_key: api_key,
            seed: 0
          })
      }
      |> LLMChain.new!()
      |> LLMChain.add_messages(system_messages)
      |> LLMChain.add_messages(conversion_messages)
      |> LLMChain.run()

    chain
  end
end
```

```elixir
send_user_message = fn chain, message ->
  chain
  |> LLMChain.add_message(Message.new_user!(message))
  |> LLMChain.run()
end
```

### Detailed instructions how to convert the model

````elixir
conversion_instructions = [
  """
  If there is a setup function, replace the calls to the stored methods in `call` with the actual Flax layer, including the parameters.
  Then remove the setup function.
  Here an example.

  INPUT:  
  ```python
  class SlightlyLargerSetup(nn.Module):  
    def setup(self):
      self.dense0 = nn.Dense(features=32)    
      self.dropout = nn.Dropout(rate=0.5)
      self.dense1 = nn.Dense(features=1)
    
    def __call__(self, x, training: bool):
      x = self.dense0(x)
      x = nn.relu(x)
      x = self.dropout(x, deterministic=not training)
      x = self.dense1(x)
      x = nn.softmax(x)
      return x
  ```
  
  OUTPUT:  
  ```python
  class SlightlyLargerSetup(nn.Module):
    
    def __call__(self, x, training: bool):
      x = nn.Dense(features=32)(x)
      x = nn.relu(x)
      x = nn.Dropout(rate=0.5)(x, deterministic=not training)
      x = nn.Dense(features=1)(x)
      x = nn.softmax(x)
      return x
  ```
  """,
  """
  If there are attributes, move them to the `call` function as parameters and replace all the references of the attributes with the function parameters.
  Here an example.
  
  INPUT:  
  ```python
  class SlightlyLargerAttributes(nn.Module):
    features_dense_0: int
    dropout_rate: int
    features_dense_1: int
  
    @nn.compact
    def __call__(self, x, training: bool):
      x = nn.Dense(features=self.features_dense_0)(x)
      x = nn.relu(x)
      x = nn.Dropout(rate=self.dropout_rate, deterministic=not training)(x)
      x = nn.Dense(features=self.features_dense_1)(x)
      x = nn.softmax(x)
      return x
  ```
  
  OUTPUT:  
  ```python
  class SlightlyLargerAttributes(nn.Module):

    @nn.compact
    def __call__(self, x, training: bool, features_dense_0: int, dropout_rate: int, features_dense_1: int):
      x = nn.Dense(features=features_dense_0)(x)
      x = nn.relu(x)
      x = nn.Dropout(rate=dropout_rate, deterministic=not training)(x)
      x = nn.Dense(features=features_dense_1)(x)
      x = nn.softmax(x)
      return x
  ```
  """,
  """
  In the `call` function, move all additional parameters when calling the layers to the initialization of the layers. Each layer should be called with a single argument.
  Here an example.

  INPUT:  
  ```python
  class SlightlyLargerAttributes(nn.Module):

    @nn.compact
    def __call__(self, x, training: bool, features_dense_0: int, dropout_rate: int, features_dense_1: int):
      x = nn.Dense(features=features_dense_0)(x)
      x = nn.relu(x)
      x = nn.Dropout(rate=dropout_rate)(x, deterministic=not training)
      x = nn.Dense(features=features_dense_1)(x)
      x = nn.softmax(x)
      return x
  ```
  
  OUTPUT:  
  ```python
  class SlightlyLargerAttributes(nn.Module):

    @nn.compact
    def __call__(self, x, training: bool, features_dense_0: int, dropout_rate: int, features_dense_1: int):
      x = nn.Dense(features=features_dense_0)(x)
      x = nn.relu(x)
      x = nn.Dropout(rate=dropout_rate, deterministic=not training)(x)
      x = nn.Dense(features=features_dense_1)(x)
      x = nn.softmax(x)
      return x
  ```
  """,  
  """
  Replace the Flax layers with the corresponding Axon layers according to our conversion table.  
  Return only the Elixir code for the model. 
  Take into account the parameters in the first parenthesis. 
  Replace initializer functions with the corresponding Axon functions. 
  Follow these rules to replace activation functions: 
  If there is an activation parameter, and the code makes use of ACT2FN[activation], replace that with Axon.activation(activation). 
  If there is an actual activation function called, replace it with Axon's activation function according to the conversion table. 
  Replace all = for arguments with :  
  Here an example.  

  INPUT:    
  ```python
  class SlightlyLarger(nn.Module):
  
    @nn.compact
    def __call__(self, x, training: bool):
      x = nn.Dense(features=32)(x)
      x = nn.relu(x)
      x = nn.Dropout(rate=0.5, deterministic=not training)(x)
      x = nn.Dense(features=1)(x)
      x = nn.softmax(x)
      return x
  ```
  
  OUTPUT:  
  ```python
  class SlightlyLarger(nn.Module):
    def __call__(self, x, training: bool):
      x = Axon.dense(x, 32)
      x = Axon.activation(x, :relu)
      x = Axon.dropout(x, rate: 0.5)
      x = Axon.dense(x, 1)
      x = Axon.activation(x, :softmax)
      x
  ```
  """,
  """
   Wrap the Axon model in a function that takes all the required parameters from the `call` function
  - name the function corresponding to the class name, but snake case.
  - take the same arguments as the `call` function
  - remove the self argument
  - remove the dtype argument
  - remove the type specs if present
  - wrap the function in do ... end

  Here an example.

  INPUT:  
  ```python
  class SlightlyLarger(nn.Module):
    def __call__(self, x, training: bool):
      x = Axon.dense(x, 32)
      x = Axon.activation(x, :relu)
      x = Axon.dropout(x, rate: 0.5)
      x = Axon.dense(x, 1)
      x = Axon.activation(x, :softmax)
      x
  ```

  OUTPUT:  
  ```python
  def slightly_larger(x, training) do
    x = Axon.dense(x, 32)
      x = Axon.activation(x, :relu)
      x = Axon.dropout(x, rate: 0.5)
      x = Axon.dense(x, 1)
      x = Axon.activation(x, :softmax)
      x
  end  
  ```
  """,  
  """
  Remove all `use` and `import` directives from the Elixir code.  
  If there are none, return the unchanged code.
  """,
  """
  Check if the function is valid Elixir code. 
  Otherwise, fix all issues by converting Python expressions to Elixir expressions. E.g. // corresponds to div, scientific notation like 1e-05 needs a decimal point in Elixir 1.0e-05.
  """
]
````

```elixir
instruction_message = fn instruction, model ->
  """
  INSTRUCTION: #{instruction}
  MODEL:
  #{model}
  """
end
```

### Extra chain for fixing general Elixir issues at the end

````elixir
defmodule FixChain do
  def new!(api_key) do
    {:ok, chain, _response} =
      %{
        llm:
          ChatOpenAI.new!(%{
            model: "gpt-4o",
            api_key: api_key,
            seed: 0
          })
      }
      |> LLMChain.new!()
      |> LLMChain.add_message(
        Message.new_system!("You are an expert in Python, Flax, Elixir and Axon.")
      )
      |> LLMChain.run()

    chain
  end

  defp fix_instruction(code) do
    """
    Fix this Elixir code according to the error message.
    Reply ONLY with the modified Elixir code.
    If you don't modify anything reply with the unchanged code.
    #{code}
    """
  end

  def fix_model(chain, model) do
    fix_instruction = fix_instruction(model)

    {:ok, _chain, response} =
      chain
      |> LLMChain.add_message(Message.new_user!(fix_instruction))
      |> LLMChain.run()

    response.content
  end

  def maybe_fix_model(model, chain, retries) do
    if retries == 0 do
      {:error, model}
    else
      dbg("trying to fix #{retries}")

      model =
        model
        |> String.trim_leading("```elixir")
        |> String.trim_trailing("```")

      dbg(model)
      
      try do
        ## check that it's valid code 
        Code.eval_string(model, [], __ENV__)
      rescue
        _ -> fix_model(chain, model) |> maybe_fix_model(chain, retries - 1)
      else
        _ -> {:ok, model}
      end
    end
  end
end
````

Build the model

```elixir
convert_model = fn conversion_chain, fix_chain, model ->
  {_, converted_model} =
    for instruction <- conversion_instructions, reduce: {conversion_chain, model} do
      {c, m} ->
        {:ok, updated_chain, response} =
          send_user_message.(c, instruction_message.(instruction, m))

        {updated_chain, response.content}
    end

  case FixChain.maybe_fix_model(converted_model, fix_chain, 3) do
    {:ok, model} -> {:ok, model}
    {:error, model} -> {:conversion_failed, model}
  end
end
```

```elixir
apply_model_fn = fn module_name, model_fn_name, args ->  
  apply(module_name, String.to_atom(model_fn_name), args)  
end
```

## Verify

### Check that Python installation works

```elixir
IO.puts("Python is here: #{python}")
{_, 0} = run_python.("print('hello from Python')", [])
```

Define paths for `safetensors` files, we will use those to work on the same numbers in Python and Elixir.

```elixir
safetensor_files = fn dir, name ->
  {Path.join(dir, "#{name}_params_axon.safetensors"),
   Path.join(dir, "#{name}_params_flax.safetensors"),
   Path.join(dir, "#{name}_test_data_axon.safetensors"),
   Path.join(dir, "#{name}_test_data_flax.safetensors")}
end
```

```elixir
defmodule ParamsUtils do
  def flatten_keys(%{} = params) do
    for key <- Map.keys(params) do
      prefixed_keys(params[key], key)
    end
    |> List.flatten()
  end

  defp prefixed_keys(%Nx.Tensor{}, key), do: key

  defp prefixed_keys(%{} = params, prefix) do
    for key <- Map.keys(params) do
      prefixed_keys(params[key], "#{prefix}.#{key}")
    end
  end

  def get_from_flattened_key(params, flattened_key) do
    keys = String.split(flattened_key, ".")

    for key <- keys, reduce: params do
      acc -> acc[key]
    end
  end

  def unflatten_and_put(params, flattened_key, value) do
    single_param_map = flattened_map(flattened_key, value)

    merge_recursive(params, single_param_map)
  end

  def merge_recursive(%{} = map1, %{} = map2) do
    Map.merge(map1, map2, fn _k, m1, m2 -> merge_recursive(m1, m2) end)
  end

  defp flattened_map(flattened_key, value) do
    case String.split(flattened_key, ".", parts: 2) do
      [key] -> %{key => value}
      [key, other_keys] -> %{key => flattened_map(other_keys, value)}
    end
  end
end
```

Must find some way to map params (using LLM?)

```elixir
get_param_mapping = fn ->
  param_mapping = %{
    "batch_norm_0.beta" => "params.normalization.bias",
    "batch_norm_0.gamma" => "params.normalization.scale",
    "batch_norm_0.mean" => "batch_stats.normalization.mean",
    "batch_norm_0.var" => "batch_stats.normalization.var",
    "conv_0.kernel" => "params.convolution.kernel"
  }
end
```

Write `safetensors` files for Axon and Flax params.

```elixir
save_params = fn params, param_mapping, axon_params_path, flax_params_path ->
  axon_params =
    for {axon_key, _} <- param_mapping, into: %{} do
      {axon_key, ParamsUtils.get_from_flattened_key(params, axon_key)}
    end

  flax_params =
    for {axon_key, flax_key} <- param_mapping, into: %{} do
      {flax_key, ParamsUtils.get_from_flattened_key(params, axon_key)}
    end

  Safetensors.write!(axon_params_path, axon_params)
  Safetensors.write!(flax_params_path, flax_params)
end
```

```elixir
model_string_fn = fn model_code, other_converted ->
  """
  defmodule ModelTest do
  #{model_code}

  #{other_converted}
  end
  """
end
```

### Run tests with random data

<!-- livebook:{"break_markdown":true} -->

First in Axon.

```elixir
run_axon_and_save = fn predict_fn, params, input_shape, path ->
  input_data =
    for dim <- Enum.reverse(Tuple.to_list(input_shape)), reduce: StreamData.float() do
      acc -> StreamData.list_of(acc, length: dim)
    end

  test_data =
    for i <- 0..100 do
      input =
        input_data
        |> Enum.take(1)
        |> hd
        |> Nx.tensor()

      input_name = "input_#{i}"
      output_name = "output_#{i}"

      output = predict_fn.(params, input)

      [{input_name, input}, {output_name, output}]
    end
    |> List.flatten()
    |> Map.new()

  Safetensors.write!(path, test_data)
end
```

Then in Flax.

```elixir
# need path for import, e.g. transformers.models.resnet.modeling_flax_resnet
run_flax_and_save = fn module, module_args, input_path, output_path, params_path, import_path ->
  test_flax =
    """
    import jax
    from typing import Any, Callable, Sequence
    from jax import random, numpy as jnp
    import flax
    from flax import linen as nn

    from functools import partial
    from typing import Optional, Tuple

    from safetensors import safe_open
    from safetensors.flax import save_file

    from transformers.models.resnet.configuration_resnet import ResNetConfig

    from #{import_path} import #{module}

    def unflatten_dict(d, sep='.'):
      result = {}
      for key, value in d.items():
          parts = key.split(sep)
          node = result
          for part in parts[:-1]:
              node = node.setdefault(part, {})
          node[parts[-1]] = value
      return result

    tensors = {}
    with safe_open("#{input_path}", framework="flax") as f:
        for k in f.keys():
            tensors[k] = f.get_tensor(k)

    print("initializing: #{module}(#{module_args})")
    model = #{module}(#{module_args})


    params = {}
    with safe_open("#{params_path}", framework="flax") as f:
        for k in f.keys():
            params[k] = f.get_tensor(k)

    params = unflatten_dict(params)

    out_tensors = tensors.copy()
    input_keys = [key for key in tensors.keys() if key.startswith("input")]
    for input_key in input_keys:  
      input = tensors[input_key]

      output = model.apply(params, input)
      output_key = input_key.replace("input", "output")

      out_tensors[output_key] = output

    save_file(out_tensors, "#{output_path}")
    """

  run_python.(test_flax, [])
end
```

Verify that we get same results.

```elixir
assert_all_close = fn left, right ->
  atol = 1.0e-4
  rtol = 1.0e-4

  equals =
    left
    |> Nx.all_close(right, atol: atol, rtol: rtol)
    |> Nx.backend_transfer(Nx.BinaryBackend)

  equals == Nx.tensor(1, type: :u8, backend: Nx.BinaryBackend)
end

same_result? = fn axon_result, flax_result ->
  assert_all_close.(axon_result, flax_result)
end

verification_results = fn axon_path, flax_path ->
  axon_data = Safetensors.read!(axon_path)
  flax_data = Safetensors.read!(flax_path)

  for output_key <- Map.keys(axon_data), String.starts_with?(output_key, "output"), into: %{} do
    input_key = String.replace(output_key, "output", "input")

    got_same? = same_result?.(axon_data[output_key], flax_data[output_key])

    {output_key,
     %{
       same_result?: got_same?,
       input: axon_data[input_key],
       axon_output: axon_data[output_key],
       flax_output: flax_data[output_key]
     }}
  end
end
```

```elixir
build_model_fn = fn model_code, axon_function_name, build_args, other_converted ->
  model = model_string_fn.(model_code, other_converted)
  Code.eval_string(model, [], __ENV__)

  model = apply_model_fn.(ModelTest, axon_function_name, build_args)

  Axon.build(model)
end
```

```elixir
get_params = fn init_fn, input_shape, input_type ->
  # get input_shape and input_type
  init_fn.(Nx.template(input_shape, input_type), %{})
end
```

```elixir
verify_model = fn model_code,
                  data_dir,
                  flax_model_name,
                  axon_function_name,
                  input_shape,
                  input_type,
                  params_mapping,
                  import_path,
                  axon_build_args,
                  flax_model_args,
                  converted ->
  stored_converted = Converted.all_to_string(converted)
  # build model
  {init_fn, predict_fn} =
    build_model_fn.(model_code, axon_function_name, axon_build_args, stored_converted)

  params = get_params.(init_fn, input_shape, input_type)
  # param_mapping = get_param_mapping.()

  # paths for safetensors files
  {axon_params_path, flax_params_path, axon_path, flax_path} =
    safetensor_files.(data_dir, axon_function_name)

  # save params
  save_params.(params, params_mapping, axon_params_path, flax_params_path)

  # run axon, save data
  run_axon_and_save.(predict_fn, params, input_shape, axon_path)

  # run flax, save data  
  run_flax_and_save.(
    flax_model_name,
    flax_model_args,
    axon_path,
    flax_path,
    flax_params_path,
    import_path
  )

  # check if results are the same 
  results = verification_results.(axon_path, flax_path)

  if Enum.all?(results, fn {_k, res} -> res.same_result? end) do
    {:ok, model_code, results}
  else
    {:verification_failed, model_code, results}
  end
end
```

## Run it all

```elixir
defmodule Converted do
  use Agent

  def start_link() do
    Agent.start_link(fn -> %{} end)
  end

  def get(converted, key) do
    Agent.get(converted, &Map.get(&1, key))
  end

  def put(converted, key, code) do
    Agent.update(converted, &Map.put(&1, key, code))
  end

  def all_to_string(converted) do
    converted_funcs = Agent.get(converted, &Map.values(&1))

    Enum.join(converted_funcs, "\n")
  end
end

{:ok, converted} = Converted.start_link()
```

```elixir
inputs = inputs_fn.(input) 

select_list = for {input, index} <- Enum.with_index(inputs) do
  [label | _] = String.split(input, "(")
  {index, label}
end

```

```elixir
target_select = Kino.Input.select("Conversion Target", select_list)
```

```elixir
model_index = Kino.Input.read(target_select)
model = Enum.at(inputs, model_index)
```

```elixir
conversion_chain = ConversionChain.new!(api_key, system_messages, conversion_messages)
fix_chain = FixChain.new!(api_key)
```

```elixir
import Kino.Shorts

next = Kino.Control.button("Run Instruction")
instruction_status = frame()
skip = Kino.Control.button("Skip Instruction")
store = Kino.Control.button("Store Converted Model")
reload_model = Kino.Control.button("Reload")

old_frame = frame()
new_frame = frame()

instruction_frame = frame()

instruction = Enum.at(conversion_instructions, 0, "return unchanged model")
instruction_length = Enum.count(conversion_instructions)

Kino.Frame.render(
  instruction_frame,
  Kino.Markdown.new("[0/#{instruction_length}] " <> instruction)
)

model_text = Kino.Input.textarea("", default: model)
Kino.Frame.render(new_frame, Kino.Input.textarea("", default: model))

conversion_layout =
  Kino.Layout.grid(
    [
      target_select,
      text(""),
      markdown("### Next LLM instruction"),
      text(""),
      instruction_frame,
      grid([next, skip, instruction_status], columns: 2),
      markdown("### Previous version"),
      markdown("### Next LLM input"),
      old_frame,
      new_frame
    ],
    boxed: true,
    columns: 2
  )

import_path = Kino.Input.text("Import Path")
input_shape = Kino.Input.text("Input Shape")
input_type = Kino.Input.text("Input Type", default: "f32")
params_mapping = Kino.Input.textarea("Params Mapping")
axon_build_args = Kino.Input.text("Axon Build Args")
flax_model_args = Kino.Input.text("Flax Model Args")

verification_button = Kino.Control.button("Run Verificiation")
result_status_frame = frame()
results_frame = frame()

verification_layout =
  Kino.Layout.grid(
    [
      target_select,
      grid(
        [
          import_path,
          input_shape,
          input_type
        ],
        boxed: true,
        columns: 2
      ),
      params_mapping,
      grid([axon_build_args, flax_model_args], boxed: true, columns: 2),
      text(""),
      text(""),
      new_frame,
      grid([verification_button, reload_model], boxed: true, columns: 2),
      result_status_frame,
      results_frame
    ],
    boxed: true,
    columns: 2
  )

layout =
  tabs(
    Conversion: conversion_layout,
    Verification: verification_layout
  )

stream =
  Kino.Control.tagged_stream(
    next: next,
    skip: skip,
    store: store,
    verification: verification_button,
    reload: reload_model
  )

Kino.nothing()
```

```elixir
Kino.listen(stream, {conversion_chain, model_text, 0}, fn event, {chain, model_input, i} ->
  case event do
    {:next, _e} ->
      instruction = Enum.at(conversion_instructions, i, "return unchanged model")

      old_text = Kino.Input.read(model_input)
      Kino.Frame.render(old_frame, Kino.Markdown.new(old_text))

      new_text = Kino.Input.read(model_input)

      Kino.Frame.render(instruction_status, text("Running instruction"))

      {:ok, updated_chain, response} =
        send_user_message.(chain, instruction_message.(instruction, new_text))

      new_text_input =
        Kino.Input.textarea("model_input", default: response.content, monospace: true)

      Kino.Frame.render(new_frame, new_text_input)

      i = i + 1

      next_instruction = Enum.at(conversion_instructions, i, "return unchanged model")

      Kino.Frame.render(
        instruction_frame,
        Kino.Markdown.new("[#{i}/#{instruction_length}] " <> next_instruction)
      )

      Kino.Frame.render(instruction_status, text("Waiting for instruction"))
      {:cont, {updated_chain, new_text_input, i}}

    {:skip, _e} ->
      i = i + 1

      next_instruction = Enum.at(conversion_instructions, i, "return unchanged model")

      Kino.Frame.render(
        instruction_frame,
        Kino.Markdown.new("[#{i}/#{instruction_length}] " <> next_instruction)
      )

      {:cont, {chain, model_input, i}}

    {:store, _e} ->
      conversion_target = Kino.Input.read(target_select)
      converted_code = Kino.Input.read(model_input)

      Converted.put(converted, conversion_target, converted_code)
      {:cont, {chain, model_input, i}}

    {:verification, _e} ->
      converted_code = Kino.Input.read(model_input)
      original_code = Kino.Input.read(model_text)

      {flax_name, axon_name} = extract_names.(original_code)

      input_type = Kino.Input.read(input_type) |> String.to_atom()
      {input_shape, _} = Kino.Input.read(input_shape) |> Code.eval_string()

      {params_mapping, _} = Kino.Input.read(params_mapping) |> Code.eval_string()

      import_path = Kino.Input.read(import_path)

      {axon_build_args, _} = Kino.Input.read(axon_build_args) |> Code.eval_string()
      flax_model_args = Kino.Input.read(flax_model_args)

      {status, model_code, results} =
        verify_model.(
          converted_code,
          data_dir,
          flax_name,
          axon_name,
          input_shape,
          input_type,
          params_mapping,
          import_path,
          axon_build_args,
          flax_model_args,
          converted
        )

      Kino.Frame.render(result_status_frame, status)

      failed = Enum.filter(results, fn {_key, value} -> not value.same_result? end)
      Kino.Frame.render(results_frame, failed)

      new_text_input =
        Kino.Input.textarea("model_input", default: converted_code, monospace: true)

      Kino.Frame.render(new_frame, new_text_input)

      {:cont, {chain, new_text_input, i}}

    {:reload, _e} ->
      converted_code = Kino.Input.read(model_input)

      new_text_input =
        Kino.Input.textarea("model_input", default: converted_code, monospace: true)

      Kino.Frame.render(new_frame, new_text_input)

      {:cont, {chain, new_text_input, i}}
  end
end)
```

### Amplify the output of the next cell

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Markdown.new("### Original Model") |> Kino.render()
Kino.render(model_text)
Kino.render(layout)
Kino.render(grid([text(""), store], columns: 2))

Kino.nothing()
```

```elixir
Converted.all_to_string(converted) |> IO.puts
```

def flax_res_net_conv_layer(x, out_channels, kernel_size, stride, activation) do

```
hidden_state = Axon.conv(x,
    out_channels,
    kernel_size: kernel_size,
    strides: stride,
    padding: [{div(kernel_size, 2), div(kernel_size, 2)}, {div(kernel_size, 2), div(kernel_size, 2)}],
    use_bias: false,
    kernel_initializer: Axon.Initializers.variance_scaling(scale: 2.0, mode: :fan_out, distribution: :normal),
)
hidden_state = Axon.batch_norm(hidden_state, momentum: 0.9, epsilon: 1.0e-05)
hidden_state = Axon.activation(hidden_state, activation) 
hidden_state
```

end

<!-- livebook:{"offset":41556,"stamp":{"token":"XCP.AqmgXgI9drRWbldbiTHhcU8fHrKAid887-ypuDb7WKQTyiRUm4tl1pHoUW1tepm-PIF0bPLgeLUwJeleoRuII5kqlmlQ3U5wZ8s-Ob1v53049uXhPA","version":2}} -->
